{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"architecture/","text":"Architecture \u00b6 There are three types roles in the system: Dispatcher : dispatcher triggers data collection tasks and divides the data points to be fetched to small batches. Connector : connecter connects to a data source through specific communication protocol. Converter : converter processes and transforms the data fetched by the connectors to data format that can be accepted by storages. Multiple converters can be applied sequentially. For example, there can be one converter to append timestamps and another converter to add additional meta information. There can be multiple instances for each role types, and they can communicate with each other through a NATS message bus. Each role instance subscribes the topic of karez.{role_type}.{role_name} in the queue {role_type}.{role_name} . For example, a connector named \"virtgen_conn\" will subscribe the topic karez.connector.virtgen_conn in the queue connector.virtgen_coon . Theoretically, one can also put all the data post-processing work in the connectors. There is no compulsive rule for which work must be implemented as converters. However, it would be a good practice to keep a connector as simple as possible to maximise the data retrieving performances. Also, it is easy to set up multiple converters to parallelise some heavy data processing procedures. Users can implement own dispatchers, connectors, and/or converters. The system will automatically search for all required plugins in the plugins directories.","title":"Architecture"},{"location":"architecture/#architecture","text":"There are three types roles in the system: Dispatcher : dispatcher triggers data collection tasks and divides the data points to be fetched to small batches. Connector : connecter connects to a data source through specific communication protocol. Converter : converter processes and transforms the data fetched by the connectors to data format that can be accepted by storages. Multiple converters can be applied sequentially. For example, there can be one converter to append timestamps and another converter to add additional meta information. There can be multiple instances for each role types, and they can communicate with each other through a NATS message bus. Each role instance subscribes the topic of karez.{role_type}.{role_name} in the queue {role_type}.{role_name} . For example, a connector named \"virtgen_conn\" will subscribe the topic karez.connector.virtgen_conn in the queue connector.virtgen_coon . Theoretically, one can also put all the data post-processing work in the connectors. There is no compulsive rule for which work must be implemented as converters. However, it would be a good practice to keep a connector as simple as possible to maximise the data retrieving performances. Also, it is easy to set up multiple converters to parallelise some heavy data processing procedures. Users can implement own dispatchers, connectors, and/or converters. The system will automatically search for all required plugins in the plugins directories.","title":"Architecture"},{"location":"cli/","text":"CLI Reference \u00b6 karez \u00b6 Usage: [OPTIONS] COMMAND [ARGS]... Options: --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. collect \u00b6 Usage: collect [OPTIONS] Options: -c, --config PATH -p, --plugin-directory PATH [default: plugins] -i, --input TEXT -o, --output TEXT --verbose / --no-verbose [default: no-verbose] config \u00b6 Usage: config [OPTIONS] PLUGIN_TYPE:{dispatcher|connector|converter} PLUGIN_NAME Options: PLUGIN_TYPE:{dispatcher|connector|converter} [required] PLUGIN_NAME [required] -p, --plugin-directory PATH [default: plugins] deploy \u00b6 Usage: deploy [OPTIONS] Options: -c, --config PATH -p, --plugin-directory PATH [default: plugins] -a, --nats-addr TEXT [default: nats://localhost:4222] -l, --logging-level TEXT [default: WARNING] -d, --dispatcher -n, --connector -v, --converter test \u00b6 Usage: test [OPTIONS] Options: -c, --config PATH -p, --plugin-directory PATH [default: plugins] -d, --dispatcher TEXT -n, --connector TEXT -v, --converter TEXT -i, --input TEXT -o, --output TEXT --verbose / --no-verbose [default: no-verbose]","title":"CLI Reference"},{"location":"cli/#cli-reference","text":"","title":"CLI Reference"},{"location":"cli/#karez","text":"Usage: [OPTIONS] COMMAND [ARGS]... Options: --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation.","title":"karez"},{"location":"cli/#collect","text":"Usage: collect [OPTIONS] Options: -c, --config PATH -p, --plugin-directory PATH [default: plugins] -i, --input TEXT -o, --output TEXT --verbose / --no-verbose [default: no-verbose]","title":"collect"},{"location":"cli/#config","text":"Usage: config [OPTIONS] PLUGIN_TYPE:{dispatcher|connector|converter} PLUGIN_NAME Options: PLUGIN_TYPE:{dispatcher|connector|converter} [required] PLUGIN_NAME [required] -p, --plugin-directory PATH [default: plugins]","title":"config"},{"location":"cli/#deploy","text":"Usage: deploy [OPTIONS] Options: -c, --config PATH -p, --plugin-directory PATH [default: plugins] -a, --nats-addr TEXT [default: nats://localhost:4222] -l, --logging-level TEXT [default: WARNING] -d, --dispatcher -n, --connector -v, --converter","title":"deploy"},{"location":"cli/#test","text":"Usage: test [OPTIONS] Options: -c, --config PATH -p, --plugin-directory PATH [default: plugins] -d, --dispatcher TEXT -n, --connector TEXT -v, --converter TEXT -i, --input TEXT -o, --output TEXT --verbose / --no-verbose [default: no-verbose]","title":"test"},{"location":"get-started/","text":"Get Started \u00b6 Docker compose \u00b6 A docker compose file has been provided in the sample directory. It will launch A InfluxDB instance to receive time-series data A telegraf instance to collect time-series data from NATS bus and send them to InfluxDB. (It works as a Aggregator as shown in the architecture diagram.) A container contains dispatchers (can be scaled to multiple instances). A container contains dispatchers (can be scaled to multiple instances). A container contains converters (can be scaled to multiple instances). Note that, a .env file is required to provide necessary configurations. INFLUXDB_USERNAME=XXX INFLUXDB_PASSWORD=XXX INFLUXDB_ORG=XXX INFLUXDB_PLATFORM_BUCKET=XXX INFLUXDB_TOKEN=XXX KAREZ_CONFIG=virtgen.yaml","title":"Get Started"},{"location":"get-started/#get-started","text":"","title":"Get Started"},{"location":"get-started/#docker-compose","text":"A docker compose file has been provided in the sample directory. It will launch A InfluxDB instance to receive time-series data A telegraf instance to collect time-series data from NATS bus and send them to InfluxDB. (It works as a Aggregator as shown in the architecture diagram.) A container contains dispatchers (can be scaled to multiple instances). A container contains dispatchers (can be scaled to multiple instances). A container contains converters (can be scaled to multiple instances). Note that, a .env file is required to provide necessary configurations. INFLUXDB_USERNAME=XXX INFLUXDB_PASSWORD=XXX INFLUXDB_ORG=XXX INFLUXDB_PLATFORM_BUCKET=XXX INFLUXDB_TOKEN=XXX KAREZ_CONFIG=virtgen.yaml","title":"Docker compose"},{"location":"reference/SUMMARY/","text":"karez cli collect common config deploy test config connector base opcua restful converter base dispatcher base default role utils plugins connector eaton_telemetry opcua virtgen_telemetry converter eaton_telemetry fix_timestamp fmt_ts_point update_info dispatcher default","title":"SUMMARY"},{"location":"reference/docs/gen_ref_pages/","text":"Generate the code reference pages and navigation.","title":"Gen ref pages"},{"location":"reference/karez/","text":"cli special \u00b6 config \u00b6 PluginType ( str , Enum ) \u00b6 An enumeration. Source code in karez/cli/config.py class PluginType ( str , Enum ): dispatcher = \"dispatcher\" connector = \"connector\" converter = \"converter\" connector special \u00b6 base \u00b6 ConnectorBase ( RoleBase , ABC ) \u00b6 Base class of connectors Source code in karez/connector/base.py class ConnectorBase ( RoleBase , ABC ): \"\"\" Base class of connectors \"\"\" def __init__ ( self , * args , ** kwargs ): super ( ConnectorBase , self ) . __init__ ( * args , ** kwargs ) self . converter = self . config . converter @classmethod def config_entities ( cls ): yield from super ( ConnectorBase , cls ) . config_entities () yield OptionalConfigEntity ( \"converter\" , None , \"Converters to be used.\" ) def reply_topic ( self , point_type = \"telemetry\" ): return f \"karez. { point_type } . { self . name } \" role \u00b6 RoleBase ( ConfigurableBase ) \u00b6 Base class for Roles (Dispatcher, Connector and Converter). Source code in karez/role.py class RoleBase ( ConfigurableBase ): \"\"\" Base class for Roles (Dispatcher, Connector and Converter). \"\"\" TYPE = NotImplemented def __init__ ( self , config , nats_addr = \"nats://localhost:4222\" ): super ( RoleBase , self ) . __init__ ( config ) self . name = self . config . name self . nc_addr = nats_addr self . nc = None self . sub = None @classmethod def config_entities ( cls ) -> Iterable [ ConfigEntityBase ]: yield from super ( RoleBase , cls ) . config_entities () conf_type = ConfigEntity ( \"type\" , \"Type of the plugin.\" ) yield OptionalConfigEntity ( \"name\" , conf_type , \"Name of the plugin.\" ) yield conf_type @classmethod @abstractmethod def role_description ( cls ) -> str : pass @property def subscribe_topic ( self ): return f \"karez. { self . TYPE } . { self . name } \" @property def subscribe_queue ( self ): return f \" { self . TYPE } . { self . name } \" @staticmethod def connector_topic ( name ): return f \"karez.connector. { name } \" @staticmethod def converter_topic ( name ): return f \"karez.converter. { name } \" async def error_cb ( self , e ): logging . error ( f ' { self . name } : { str ( e ) } !' ) async def disconnected_cb ( self ): logging . warning ( f ' { self . name } : Got disconnected!' ) self . sub = None async def reconnected_cb ( self ): logging . info ( f ' { self . name } : Got reconnected to { self . nc . connected_url . netloc } ' ) async def async_ensure_init ( self ): conn_options = dict ( servers = self . nc_addr , name = self . name , error_cb = self . error_cb , disconnected_cb = self . disconnected_cb , reconnected_cb = self . reconnected_cb ) try : if not self . nc : self . nc = await nats . connect ( ** conn_options ) elif not self . nc . is_connected : await self . nc . connect ( ** conn_options ) except Exception as e : logging . error ( str ( e )) return self . nc and self . nc . is_connected async def _subscribe_handler ( self , msg ): pass @abstractmethod async def process ( self , payload ): pass async def subscribe ( self ): if await self . async_ensure_init (): if self . sub : await self . sub . unsubscribe () self . sub = None print ( self . name , self . subscribe_topic , self . subscribe_queue ) self . sub = await self . nc . subscribe ( self . subscribe_topic , queue = self . subscribe_queue , cb = self . _subscribe_handler )","title":"karez"},{"location":"reference/karez/#karez.cli","text":"","title":"cli"},{"location":"reference/karez/#karez.cli.config","text":"","title":"config"},{"location":"reference/karez/#karez.cli.config.PluginType","text":"An enumeration. Source code in karez/cli/config.py class PluginType ( str , Enum ): dispatcher = \"dispatcher\" connector = \"connector\" converter = \"converter\"","title":"PluginType"},{"location":"reference/karez/#karez.connector","text":"","title":"connector"},{"location":"reference/karez/#karez.connector.base","text":"","title":"base"},{"location":"reference/karez/#karez.connector.base.ConnectorBase","text":"Base class of connectors Source code in karez/connector/base.py class ConnectorBase ( RoleBase , ABC ): \"\"\" Base class of connectors \"\"\" def __init__ ( self , * args , ** kwargs ): super ( ConnectorBase , self ) . __init__ ( * args , ** kwargs ) self . converter = self . config . converter @classmethod def config_entities ( cls ): yield from super ( ConnectorBase , cls ) . config_entities () yield OptionalConfigEntity ( \"converter\" , None , \"Converters to be used.\" ) def reply_topic ( self , point_type = \"telemetry\" ): return f \"karez. { point_type } . { self . name } \"","title":"ConnectorBase"},{"location":"reference/karez/#karez.role","text":"","title":"role"},{"location":"reference/karez/#karez.role.RoleBase","text":"Base class for Roles (Dispatcher, Connector and Converter). Source code in karez/role.py class RoleBase ( ConfigurableBase ): \"\"\" Base class for Roles (Dispatcher, Connector and Converter). \"\"\" TYPE = NotImplemented def __init__ ( self , config , nats_addr = \"nats://localhost:4222\" ): super ( RoleBase , self ) . __init__ ( config ) self . name = self . config . name self . nc_addr = nats_addr self . nc = None self . sub = None @classmethod def config_entities ( cls ) -> Iterable [ ConfigEntityBase ]: yield from super ( RoleBase , cls ) . config_entities () conf_type = ConfigEntity ( \"type\" , \"Type of the plugin.\" ) yield OptionalConfigEntity ( \"name\" , conf_type , \"Name of the plugin.\" ) yield conf_type @classmethod @abstractmethod def role_description ( cls ) -> str : pass @property def subscribe_topic ( self ): return f \"karez. { self . TYPE } . { self . name } \" @property def subscribe_queue ( self ): return f \" { self . TYPE } . { self . name } \" @staticmethod def connector_topic ( name ): return f \"karez.connector. { name } \" @staticmethod def converter_topic ( name ): return f \"karez.converter. { name } \" async def error_cb ( self , e ): logging . error ( f ' { self . name } : { str ( e ) } !' ) async def disconnected_cb ( self ): logging . warning ( f ' { self . name } : Got disconnected!' ) self . sub = None async def reconnected_cb ( self ): logging . info ( f ' { self . name } : Got reconnected to { self . nc . connected_url . netloc } ' ) async def async_ensure_init ( self ): conn_options = dict ( servers = self . nc_addr , name = self . name , error_cb = self . error_cb , disconnected_cb = self . disconnected_cb , reconnected_cb = self . reconnected_cb ) try : if not self . nc : self . nc = await nats . connect ( ** conn_options ) elif not self . nc . is_connected : await self . nc . connect ( ** conn_options ) except Exception as e : logging . error ( str ( e )) return self . nc and self . nc . is_connected async def _subscribe_handler ( self , msg ): pass @abstractmethod async def process ( self , payload ): pass async def subscribe ( self ): if await self . async_ensure_init (): if self . sub : await self . sub . unsubscribe () self . sub = None print ( self . name , self . subscribe_topic , self . subscribe_queue ) self . sub = await self . nc . subscribe ( self . subscribe_topic , queue = self . subscribe_queue , cb = self . _subscribe_handler )","title":"RoleBase"},{"location":"reference/karez/config/","text":"","title":"config"},{"location":"reference/karez/role/","text":"RoleBase ( ConfigurableBase ) \u00b6 Base class for Roles (Dispatcher, Connector and Converter). Source code in karez/role.py class RoleBase ( ConfigurableBase ): \"\"\" Base class for Roles (Dispatcher, Connector and Converter). \"\"\" TYPE = NotImplemented def __init__ ( self , config , nats_addr = \"nats://localhost:4222\" ): super ( RoleBase , self ) . __init__ ( config ) self . name = self . config . name self . nc_addr = nats_addr self . nc = None self . sub = None @classmethod def config_entities ( cls ) -> Iterable [ ConfigEntityBase ]: yield from super ( RoleBase , cls ) . config_entities () conf_type = ConfigEntity ( \"type\" , \"Type of the plugin.\" ) yield OptionalConfigEntity ( \"name\" , conf_type , \"Name of the plugin.\" ) yield conf_type @classmethod @abstractmethod def role_description ( cls ) -> str : pass @property def subscribe_topic ( self ): return f \"karez. { self . TYPE } . { self . name } \" @property def subscribe_queue ( self ): return f \" { self . TYPE } . { self . name } \" @staticmethod def connector_topic ( name ): return f \"karez.connector. { name } \" @staticmethod def converter_topic ( name ): return f \"karez.converter. { name } \" async def error_cb ( self , e ): logging . error ( f ' { self . name } : { str ( e ) } !' ) async def disconnected_cb ( self ): logging . warning ( f ' { self . name } : Got disconnected!' ) self . sub = None async def reconnected_cb ( self ): logging . info ( f ' { self . name } : Got reconnected to { self . nc . connected_url . netloc } ' ) async def async_ensure_init ( self ): conn_options = dict ( servers = self . nc_addr , name = self . name , error_cb = self . error_cb , disconnected_cb = self . disconnected_cb , reconnected_cb = self . reconnected_cb ) try : if not self . nc : self . nc = await nats . connect ( ** conn_options ) elif not self . nc . is_connected : await self . nc . connect ( ** conn_options ) except Exception as e : logging . error ( str ( e )) return self . nc and self . nc . is_connected async def _subscribe_handler ( self , msg ): pass @abstractmethod async def process ( self , payload ): pass async def subscribe ( self ): if await self . async_ensure_init (): if self . sub : await self . sub . unsubscribe () self . sub = None print ( self . name , self . subscribe_topic , self . subscribe_queue ) self . sub = await self . nc . subscribe ( self . subscribe_topic , queue = self . subscribe_queue , cb = self . _subscribe_handler )","title":"role"},{"location":"reference/karez/role/#karez.role.RoleBase","text":"Base class for Roles (Dispatcher, Connector and Converter). Source code in karez/role.py class RoleBase ( ConfigurableBase ): \"\"\" Base class for Roles (Dispatcher, Connector and Converter). \"\"\" TYPE = NotImplemented def __init__ ( self , config , nats_addr = \"nats://localhost:4222\" ): super ( RoleBase , self ) . __init__ ( config ) self . name = self . config . name self . nc_addr = nats_addr self . nc = None self . sub = None @classmethod def config_entities ( cls ) -> Iterable [ ConfigEntityBase ]: yield from super ( RoleBase , cls ) . config_entities () conf_type = ConfigEntity ( \"type\" , \"Type of the plugin.\" ) yield OptionalConfigEntity ( \"name\" , conf_type , \"Name of the plugin.\" ) yield conf_type @classmethod @abstractmethod def role_description ( cls ) -> str : pass @property def subscribe_topic ( self ): return f \"karez. { self . TYPE } . { self . name } \" @property def subscribe_queue ( self ): return f \" { self . TYPE } . { self . name } \" @staticmethod def connector_topic ( name ): return f \"karez.connector. { name } \" @staticmethod def converter_topic ( name ): return f \"karez.converter. { name } \" async def error_cb ( self , e ): logging . error ( f ' { self . name } : { str ( e ) } !' ) async def disconnected_cb ( self ): logging . warning ( f ' { self . name } : Got disconnected!' ) self . sub = None async def reconnected_cb ( self ): logging . info ( f ' { self . name } : Got reconnected to { self . nc . connected_url . netloc } ' ) async def async_ensure_init ( self ): conn_options = dict ( servers = self . nc_addr , name = self . name , error_cb = self . error_cb , disconnected_cb = self . disconnected_cb , reconnected_cb = self . reconnected_cb ) try : if not self . nc : self . nc = await nats . connect ( ** conn_options ) elif not self . nc . is_connected : await self . nc . connect ( ** conn_options ) except Exception as e : logging . error ( str ( e )) return self . nc and self . nc . is_connected async def _subscribe_handler ( self , msg ): pass @abstractmethod async def process ( self , payload ): pass async def subscribe ( self ): if await self . async_ensure_init (): if self . sub : await self . sub . unsubscribe () self . sub = None print ( self . name , self . subscribe_topic , self . subscribe_queue ) self . sub = await self . nc . subscribe ( self . subscribe_topic , queue = self . subscribe_queue , cb = self . _subscribe_handler )","title":"RoleBase"},{"location":"reference/karez/utils/","text":"","title":"utils"},{"location":"reference/karez/cli/","text":"config \u00b6 PluginType ( str , Enum ) \u00b6 An enumeration. Source code in karez/cli/config.py class PluginType ( str , Enum ): dispatcher = \"dispatcher\" connector = \"connector\" converter = \"converter\"","title":"cli"},{"location":"reference/karez/cli/#karez.cli.config","text":"","title":"config"},{"location":"reference/karez/cli/#karez.cli.config.PluginType","text":"An enumeration. Source code in karez/cli/config.py class PluginType ( str , Enum ): dispatcher = \"dispatcher\" connector = \"connector\" converter = \"converter\"","title":"PluginType"},{"location":"reference/karez/cli/collect/","text":"","title":"collect"},{"location":"reference/karez/cli/common/","text":"","title":"common"},{"location":"reference/karez/cli/config/","text":"PluginType ( str , Enum ) \u00b6 An enumeration. Source code in karez/cli/config.py class PluginType ( str , Enum ): dispatcher = \"dispatcher\" connector = \"connector\" converter = \"converter\"","title":"config"},{"location":"reference/karez/cli/config/#karez.cli.config.PluginType","text":"An enumeration. Source code in karez/cli/config.py class PluginType ( str , Enum ): dispatcher = \"dispatcher\" connector = \"connector\" converter = \"converter\"","title":"PluginType"},{"location":"reference/karez/cli/deploy/","text":"","title":"deploy"},{"location":"reference/karez/cli/test/","text":"","title":"test"},{"location":"reference/karez/connector/","text":"base \u00b6 ConnectorBase ( RoleBase , ABC ) \u00b6 Base class of connectors Source code in karez/connector/base.py class ConnectorBase ( RoleBase , ABC ): \"\"\" Base class of connectors \"\"\" def __init__ ( self , * args , ** kwargs ): super ( ConnectorBase , self ) . __init__ ( * args , ** kwargs ) self . converter = self . config . converter @classmethod def config_entities ( cls ): yield from super ( ConnectorBase , cls ) . config_entities () yield OptionalConfigEntity ( \"converter\" , None , \"Converters to be used.\" ) def reply_topic ( self , point_type = \"telemetry\" ): return f \"karez. { point_type } . { self . name } \"","title":"connector"},{"location":"reference/karez/connector/#karez.connector.base","text":"","title":"base"},{"location":"reference/karez/connector/#karez.connector.base.ConnectorBase","text":"Base class of connectors Source code in karez/connector/base.py class ConnectorBase ( RoleBase , ABC ): \"\"\" Base class of connectors \"\"\" def __init__ ( self , * args , ** kwargs ): super ( ConnectorBase , self ) . __init__ ( * args , ** kwargs ) self . converter = self . config . converter @classmethod def config_entities ( cls ): yield from super ( ConnectorBase , cls ) . config_entities () yield OptionalConfigEntity ( \"converter\" , None , \"Converters to be used.\" ) def reply_topic ( self , point_type = \"telemetry\" ): return f \"karez. { point_type } . { self . name } \"","title":"ConnectorBase"},{"location":"reference/karez/connector/base/","text":"ConnectorBase ( RoleBase , ABC ) \u00b6 Base class of connectors Source code in karez/connector/base.py class ConnectorBase ( RoleBase , ABC ): \"\"\" Base class of connectors \"\"\" def __init__ ( self , * args , ** kwargs ): super ( ConnectorBase , self ) . __init__ ( * args , ** kwargs ) self . converter = self . config . converter @classmethod def config_entities ( cls ): yield from super ( ConnectorBase , cls ) . config_entities () yield OptionalConfigEntity ( \"converter\" , None , \"Converters to be used.\" ) def reply_topic ( self , point_type = \"telemetry\" ): return f \"karez. { point_type } . { self . name } \"","title":"base"},{"location":"reference/karez/connector/base/#karez.connector.base.ConnectorBase","text":"Base class of connectors Source code in karez/connector/base.py class ConnectorBase ( RoleBase , ABC ): \"\"\" Base class of connectors \"\"\" def __init__ ( self , * args , ** kwargs ): super ( ConnectorBase , self ) . __init__ ( * args , ** kwargs ) self . converter = self . config . converter @classmethod def config_entities ( cls ): yield from super ( ConnectorBase , cls ) . config_entities () yield OptionalConfigEntity ( \"converter\" , None , \"Converters to be used.\" ) def reply_topic ( self , point_type = \"telemetry\" ): return f \"karez. { point_type } . { self . name } \"","title":"ConnectorBase"},{"location":"reference/karez/connector/opcua/","text":"","title":"opcua"},{"location":"reference/karez/connector/restful/","text":"","title":"restful"},{"location":"reference/karez/converter/","text":"","title":"converter"},{"location":"reference/karez/converter/base/","text":"","title":"base"},{"location":"reference/karez/dispatcher/","text":"","title":"dispatcher"},{"location":"reference/karez/dispatcher/base/","text":"","title":"base"},{"location":"reference/karez/dispatcher/default/","text":"","title":"default"},{"location":"reference/plugins/connector/eaton_telemetry/","text":"","title":"eaton_telemetry"},{"location":"reference/plugins/connector/opcua/","text":"","title":"opcua"},{"location":"reference/plugins/connector/virtgen_telemetry/","text":"","title":"virtgen_telemetry"},{"location":"reference/plugins/converter/eaton_telemetry/","text":"","title":"eaton_telemetry"},{"location":"reference/plugins/converter/fix_timestamp/","text":"","title":"fix_timestamp"},{"location":"reference/plugins/converter/fmt_ts_point/","text":"","title":"fmt_ts_point"},{"location":"reference/plugins/converter/update_info/","text":"","title":"update_info"},{"location":"reference/plugins/dispatcher/default/","text":"","title":"default"}]}